<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Game</title>
    <script src="../scripts/vue.js"></script>
    <script src="../scripts/tweenlite.min.js"></script>
    <script src="game2048.js"></script>
    <style>
        body, html {
            font-family: 'Source Sans Pro', Arial, sans-serif;
            color: #2c3e50;
            font-size: 18px;
        }

        .half-white {
            background-color: white;
            opacity: 0.7;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            margin: 0 auto;
        }

            .main-container .score-container {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

                .main-container .score-container .game-aim {
                    font-weight: bold;
                    font-size: 4em;
                }

                .main-container .score-container .scores {
                    font-weight: bold;
                    font-size: 1.5em;
                    display: flex;
                    justify-content: space-around;
                    width: 50%;
                }

                    .main-container .score-container .scores .score {
                        position: relative;
                        text-align: center;
                        color: white;
                        background-color: #9aa4af;
                        border-radius: 5%/ 8%;
                        width: 100%;
                        margin: 2%;
                    }

                        .main-container .score-container .scores .score .score-inc {
                            position: absolute;
                            left: 0;
                            color: #2c3e50;
                            width: 100%;
                            animation: up-disappear 1.5s;
                        }

                        .main-container .score-container .scores .score .label {
                            color: honeydew;
                            font-size:1rem;
                        }


            .main-container .game-controls {
                display: flex;
                justify-content: flex-end;
                align-items: center;
                width: 100%;
            }

                .main-container .game-controls .button {
                    background-color: #35495e;
                    border: none;
                    border-radius: 5% / 9%;
                    width: 25%;
                    height: 75%;
                    color: white;
                    outline: none;
                    animation: appearing;
                    font-weight: bold;
                    overflow: hidden;
                    cursor: pointer;
                    animation: appearing 0.5s;
                    font-size: 18px;
                }

                .main-container .game-controls .size-control {
                    width: 75%;
                    font-weight: bold;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    animation: appearing 0.5s;
                }

                    .main-container .game-controls .size-control input[type=radio]:not(checked) {
                        position: absolute;
                        opacity: 0;
                    }

                    .main-container .game-controls .size-control input[type=radio] + label {
                        cursor: pointer;
                        border: 5px solid #35495e;
                        height: 30px;
                        width: 30px;
                        display: inline-flex;
                        border-radius: 50%;
                        justify-content: center;
                        align-items: center;
                        position: relative;
                        vertical-align: middle;
                        font-weight: bold;
                        transition: background-color 0.3s, color 0.3s;
                    }

                    .main-container .game-controls .size-control input[type=radio]:checked + label {
                        background: #41b883;
                        color: honeydew;
                    }

            .main-container .game-container {
                position: relative;
            }

                .main-container .game-container .overlay {
                    width: 100%;
                    height: 100%;
                    position: absolute;
                    z-index: 2;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

        .game-over {
            font-weight: bold;
            text-align: center;
        }

        .appearing {
            animation: appearing 1s;
        }

        .appearing07 {
            animation: appearing07 1s;
        }

        @keyframes appearing {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes up-disappear {
            0% {
                opacity: 0.7;
            }

            100% {
                opacity: 0;
                transform: translateY(-40px);
            }
        }

        @keyframes appearing07 {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 0.7;
            }
        }

        .board {
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            align-items: space-around;
            background-color: #35495e;
            outline: none;
        }

            .board .cell {
                background-color: #41b883;
                position: relative;
                border-radius: 7%;
            }

                .board .cell .chip {
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    overflow: hidden;
                    text-align: justify;
                    font-weight: bold;
                    background-color: honeydew;
                    z-index: 1;
                    border-radius: 7%;
                }

        @keyframes chip-value-changed {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes chip-appear {
            0% {
                transform: scale(0);
            }

            100% {
                transform: scale(1);
            }
        }
    </style>
</head>
<body>
    <div id="app" style="display:none">
        <div class="main-container appearing" :style="mainContainerStyle">
            <div class="score-container" :style="scoreContainerStyle">
                <div class="game-aim">
                    {{gameAim}}
                </div>
                <div class="scores">
                    <div class="score">
                        <div class="label">Score</div>
                        <div>
                            {{score}}
                            <transition>
                                <span v-if="scoreInc!=''" class="score-inc">{{scoreInc}}</span>
                            </transition>
                        </div>
                    </div>
                    <div class="score"><div class="label">Best</div><div>{{bestScore[size]}}</div></div>
                </div>
            </div>
            <div class="game-controls" :style="gameControlsStyle">
                <div class="size-control" v-if="!gameStarted">
                    Size:
                    <template v-for="s in sizes">
                        <input type="radio" :id="'size-radio'+s" :value="s" v-model.number="size" />
                        <label :for="'size-radio'+s">{{s}}</label>
                    </template>&nbsp;
                </div>
                <button v-if="!gameStarted" @click="startGame()" class="button" key="start">New Game</button>
                <button v-else @click="gameStarted=false" class="button" key="end">End</button>
            </div>
            <div class="game-container" :style="gameContainerStyle">
                <div v-if="gameEnded">
                    <div class="overlay half-white appearing07"></div>
                    <div class="overlay game-over appearing" :style="gameOverStyle">
                        <p>Game over!</p>
                    </div>
                </div>
                <game-2048 ref="game" :size="size"
                           :listen-own-key-events-only="false"
                           :tab-index="1"
                           :board-size-px="boardSizePx"
                           :started="gameStarted"
                           @started="onGameStarted"
                           @ended="onGameEnded"
                           @score="onGameScore"
                           @aim-changed="onGameAimChanged"></game-2048>
            </div>
        </div>
    </div>

    <template id="game2048-chip" hidden>
        <transition :css="false" @enter="enter">
            <div class="chip" :style="style">{{chip.value}}</div>
        </transition>
    </template>

    <template id="game2048" hidden>
        <div class="board" :tabindex="tabIndex" :style="boardStyle">
            <div ref="cells" v-for="(cl, index) in cells" class="cell" :key="cl" :style="cellStyle">
                <game2048-chip ref="chips" v-for="(ch, i) in cl.chips" :key="ch" :animation-time-ms="animationTimeMs"
                               :chip="ch"
                               :size-px="cellSizePx"></game2048-chip>
            </div>
        </div>
    </template>
    <script>

        (function () {
            var fontSizeCoefs = [1, 1, 0.8, 0.65, 0.5, 0.4, 0.35, 0.32]

            Vue.component('game2048-chip', {
                template: '#game2048-chip',
                props: {
                    chip: { type: Object },
                    sizePx: { type: Number },
                    animationTimeMs: { type: Number }
                },
                computed: {
                    style: function () {
                        return {
                            fontSize: this.fontSizePx + 'px',
                        }
                    },
                    fontSizePx: function () {
                        var n = Math.floor(Math.log(this.chip.value) / Math.log(10))
                        var b = Math.floor(this.sizePx / 1.5)
                        return b * (n < 8 ? fontSizeCoefs[n] : fontSizeCoefs[7])
                    }
                },
                watch: {
                    'chip.value': function () {
                        var el = this.$el
                        if (el) {
                            el.style.animation = 'chip-value-changed ' + this.animationTimeMs + 'ms'
                        }
                    }
                },
                methods: {
                    enter: function (el, done) {
                        var self = this
                        if (this.chip.prevRelPos) {
                            var p = this.chip.prevRelPos
                            el.style.transform = 'translate(' + p.left + 'px,' + p.top + 'px)'
                            requestAnimationFrame(function () {
                                requestAnimationFrame(function () {
                                    el.style.transition = 'transform ' + self.animationTimeMs + 'ms'
                                    el.style.transform = '';
                                })
                            })
                        }
                        else {
                            el.style.animation = 'chip-appear ' + this.animationTimeMs + 'ms'
                        }
                    }
                }
            })
        })();

        (function () {

            function deffered(delayMs, func) {
                var executed = false;
                function execute() {
                    if (!executed) {
                        func()
                        executed = true
                    }
                }
                function renew() {
                    executed = false
                    setTimeout(execute, delayMs)
                }
                renew()
                return {
                    finish: execute,
                    renew: renew
                }
            }

            function createSwipeListener(onSwipe) {

                var sens = 10
                var st

                function onStart(e) {
                    st = e.touches[0]
                    e.preventDefault()
                }

                function onEnd(e) {
                    var et = e.changedTouches[0]
                    var x = st.clientX - et.clientX
                    var y = st.clientY - et.clientY
                    var mx = Math.abs(x)
                    var my = Math.abs(y)
                    if (mx < sens && my < sens)
                        return

                    var d = mx > my
                        ? x > 0 ? 'left' : 'right'
                        : y > 0 ? 'up' : 'down'
                    onSwipe(d)
                }

                return {
                    attach: function (el) {
                        el.addEventListener('touchstart', onStart, false)
                        el.addEventListener('touchend', onEnd, false)
                    },
                    detach: function (el) {
                        el.removeEventListener('touchstart', onStart)
                        el.removeEventListener('touchend', onEnd)
                    }
                }
            }

            var keyMap = {}
            keyMap[37] = 'left'
            keyMap[38] = 'up'
            keyMap[39] = 'right'
            keyMap[40] = 'down'

            var aimMap = []
            aimMap[3] = 256
            aimMap[4] = 2048
            aimMap[5] = 4096
            aimMap[6] = 8192

            Vue.component('game2048', {
                template: '#game2048',
                props: {
                    size: { type: Number },
                    listenOwnKeyEventsOnly: { type: Boolean, default: false },
                    tabIndex: { type: Number, default: 1 },
                    boardSizePx: { type: Number, default: 0 },
                    animationTimeMs: { type: Number, default: 150 },
                    started: { type: Boolean, default: false }
                },
                data: function () {
                    return {
                        cells: this.createCells(),
                        boardSizeAutoPx: 0,
                        aim: 2048
                    }
                },
                mounted: function () {
                    this.boardSizeAutoPx = this.boardSizePx > 0
                        ? this.boardSizePx
                        : this.$el.getBoundingClientRect().width
                },
                watch: {
                    size: function () {
                        this.cells = this.createCells()
                        this.aim = aimMap[this.size] || 2048
                        this.$emit('aim-changed', this.aim)
                    },
                    started: function (nv, ov) {
                        if (nv) {
                            this.startGame()
                        }
                        else {
                            this.endGame();
                        }
                    }
                },
                computed: {
                    boardStyle: function () {
                        return {
                            width: this.boardSizePx > 0 ? this.boardSizePx + 'px' : '100%',
                            height: this.boardSizePx > 0 ? this.boardSizePx + 'px' : '100%',
                            borderRadius: 7 / this.size + '%'
                        }
                    },
                    cellStyle: function () {
                        return {
                            width: this.cellSizePct + '%',
                            height: this.cellSizePct + '%',
                            marginLeft: this.cellMarginPct + '%',
                            marginTop: this.cellMarginPct + '%',
                        }
                    },
                    cellSizePct: function () {
                        return 8 * this.cellMarginPct
                    },
                    cellMarginPct: function () {
                        return 100 / (9 * this.size + 1)
                    },
                    cellSizePx: function () {
                        return this.cellSizePct / 100 *
                            (this.boardSizePx > 0 ? this.boardSizePx : this.boardSizeAutoPx)
                    }
                },
                methods: {
                    startGame: function () {
                        this.emptyCells()
                        var game = createGame2048(this.size)
                        for (var i = Math.max(2, this.size - 2); i > 0; i--) {
                            var chips = game.turn()
                            this.addChips(chips)
                        }
                        var doGameMove = this.createGameMove(game)
                        this.runKeyboardControl(doGameMove)
                        this.runTouchControl(doGameMove)
                        this.$emit('started', this)
                    },

                    runKeyboardControl: function (doGameMove) {
                        var listenKeysOn = this.listenOwnKeyEventsOnly ? this.$el : document
                        var h = function (e) {
                            var m = keyMap[e.keyCode]
                            if (m == null)
                                return
                            e.preventDefault()
                            doGameMove(m)
                        }
                        listenKeysOn.addEventListener('keydown', h)
                        this.$once('ended', function () {
                            listenKeysOn.removeEventListener('keydown', h)
                        })
                    },

                    runTouchControl: function (doGameMove) {
                        var sw = createSwipeListener(function (m) {
                            doGameMove(m)
                        })
                        var el = this.$el
                        sw.attach(el)
                        this.$once('ended', function () {
                            sw.detach(el)
                        })
                    },

                    createGameMove: function (game) {
                        var self = this
                        var boardChanges = { consolidations: [] }
                        var newChips = []
                        var consolidateAndAddChipsDeffered = deffered(self.animationTimeMs,
                            function () {
                                self.consolidateChips(boardChanges.consolidations)
                                self.addChips(newChips)
                            })

                        return function (m) {
                            consolidateAndAddChipsDeffered.finish()

                            boardChanges = game[m]()
                            newChips.length = 0
                            if (boardChanges.moves.length > 0) {
                                for (var i = Math.max(1, self.size - 3); i > 0; i--) {
                                    var chips = game.turn()
                                    chips.push.apply(newChips, chips)
                                }
                                if (boardChanges.scoreInc > 0) {
                                    self.$emit('score', { score: game.score(), scoreInc: boardChanges.scoreInc })
                                    if (game.score() >= self.aim) {
                                        self.$emit('aim-reached')
                                    }
                                }
                            }

                            self.moveChips(boardChanges.moves)
                            consolidateAndAddChipsDeffered.renew()
                            if (!game.canMove()) {
                                setTimeout(function () {
                                    self.endGame()
                                }, self.animationTimeMs)
                            }
                        }
                    },

                    endGame: function () {
                        this.$emit('ended', this)
                    },

                    consolidateChips: function (consolidations) {
                        var self = this
                        consolidations.forEach(function (c) {
                            var cell = self.getCell(c)
                            var chips = cell.chips
                            chips.splice(0, chips.length - 1)
                            chips[0].value = c.value
                        })
                    },
                    moveChips: function (moves) {
                        for (var i = 0; i < moves.length; i++)
                            this.moveChip(moves[i].from, moves[i].to)
                    },
                    moveChip: function (from, to) {
                        var fcell = this.getCell(from)
                        var fcellEl = this.getCellEl(from)
                        var tcell = this.getCell(to)
                        var tcellEl = this.getCellEl(to)
                        var chip = fcell.chips.splice(0, 1)[0]
                        var fboundRect = fcellEl.getBoundingClientRect()
                        var tboundRect = tcellEl.getBoundingClientRect()
                        chip.prevRelPos = { left: fboundRect.left - tboundRect.left, top: fboundRect.top - tboundRect.top }
                        tcell.chips.push(chip)
                    },
                    addChips: function (chips) {
                        chips.forEach(this.addChip)
                    },
                    addChip: function (c) {
                        this.cells[this.getCellIndex(c)].chips.push({ value: c.value })
                    },
                    getCellIndex: function (c) {
                        return c.y * this.size + c.x
                    },
                    getCell: function (c) {
                        return this.cells[this.getCellIndex(c)]
                    },
                    getCellEl: function (c) {
                        return this.$refs.cells[this.getCellIndex(c)]
                    },
                    createCells: function () {
                        return Array.apply(null, { length: this.size * this.size })
                            .map(function () { return { chips: [] } })
                    },
                    emptyCells: function () {
                        this.cells.forEach(function (c) { c.chips.splice(0) })
                    }
                }
            })
        })()

        var app = new Vue({
            el: '#app',
            data: function () {
                var sizes = [3, 4, 5, 6]
                var bestScore = []
                for (var i in sizes)
                    bestScore[sizes[i]] = 0

                return {
                    boardSizePx: 450,
                    size: 4,
                    sizes: sizes,
                    gameStarted: false,
                    gameEnded: false,
                    gameAim: 2048,
                    score: 0,
                    scoreInc: '',
                    bestScore: bestScore
                }
            },
            created: function () {
                this.loadBestScore()
            },
            mounted: function () {
                this.$el.style.display = ''
            },
            computed: {
                gameOverStyle: function () {
                    return { fontSize: this.boardSizePx / 5 + 'px' }
                },
                gameContainerStyle: function () {
                    return {
                        width: this.boardSizePx + 'px',
                        height: this.boardSizePx + 'px'
                    }
                },
                mainContainerStyle: function () {
                    return {
                        width: this.boardSizePx + 'px',
                    }
                },
                gameControlsStyle: function () {
                    return {
                        height: (this.boardSizePx * 0.15) + 'px'
                    }
                },
                scoreContainerStyle: function () {
                    return {
                        height: (this.boardSizePx * 0.15) + 'px'
                    }
                }
            },
            watch: {
                size: function () {
                    this.gameEnded = false
                }
            },
            methods: {
                loadBestScore: function () {
                    try {
                        var bs = document.cookie
                        if (bs)
                            this.bestScore = bs ? JSON.parse(bs) : 0
                    }
                    catch (e) {
                    }
                },
                saveBestScore: function () {
                    try {
                        document.cookie = JSON.stringify(this.bestScore)
                    }
                    catch (e) {
                    }
                },
                startGame: function () {
                    this.gameStarted = true
                    this.score = 0
                },
                onGameStarted: function () {
                    this.gameStarted = true
                    this.gameEnded = false
                },
                onGameEnded: function () {
                    this.gameStarted = false
                    this.gameEnded = true
                    this.saveBestScore()
                },
                onGameScore: function (args) {
                    var s = { score: this.score }
                    var self = this
                    TweenLite.to(s, 0.3, {
                        score: args.score, ease: Power0.easeNone, onUpdate: function () {
                            self.score = Math.floor(s.score)
                        }
                    })

                    if (args.score > this.bestScore[this.size]) {
                        var bs = { score: this.bestScore[this.size] }
                        TweenLite.to(bs, 0.3, {
                            score: args.score, ease: Power0.easeNone, onUpdate: function () {
                                Vue.set(self.bestScore, self.size, Math.floor(bs.score))
                            }
                        })
                    }

                    this.scoreInc = args.scoreInc + '+'
                    Vue.nextTick(function () { self.scoreInc = '' })
                },
                onGameAimChanged: function (aim) {
                    this.gameAim = aim
                }
            }
        })
    </script>
</body>
</html>